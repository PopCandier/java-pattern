#### 状态模式（State Pattern）

也称为状态机模式（State Machine Pattern），是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。

**属于行为性模式**

不同状态对应不同的行为，不同的状态，用不同的类进行表示

网购，订单状态。



#### 状态模式的适用场景

* 行为随着状态改变而改变的场景
* 一个操作中含有大量的多分枝结构，并且这些分支取决于对象的状态

 

#### 状态模式相关的设计模式

* 状态模式与责任链模式
  * 状态模式强调的是内部状态的切换，对客户端而言，他只是调用一个方法，某个对象的状态自己也就改变了，责任链则是对对象的不同方式的处理，且客户端需要对责任链的责任处理自己组装。
  * 另外，被处理的对象，并不知道自己会被哪个责任节点处理完毕，或者被处理，因为可能存在处理不了的情况，所以责任链状态下，对象的具体情况未知，对于处理某个责任节点处理不了的情况下，会被以踢皮球的方式，传递给下一个责任节点。而状态模式，在内部已经定义好了下一步具体做什么，请求被初始化好，每个环节都被明确定义状态，不存在未知状态。
  * 都避免了使用`if...else` 之类的判断分支
* 状态模式与策略模式
  * UML图看起来并没有什么本质差别，但是使用还是很差别的，策略模式需要用户去选择算法，且算法与算法之间并没有关联，彼此独立存在，而状态模式对于用户而言，具体状态，或者算法是内置，不需要用户却选择，内部自行切换，无法进行干扰。



#### 状态模式的优点

* 结构清晰，将状态独立为类，交出了冗余的`if...else`或 `switch...case`语句，使代码更加简洁，提高系统可维护性
* 将状态转化显示化：通常的对象内部都是使用数值类型来定义状态，状态的切换是通过赋值来表现，不够直观，而使用状态类，在切换状态时，是以不同的类来表示，转换的目的更加明确
* 状态类职责明确且具备扩展性。

#### 状态模式的缺点

* 类膨胀，如果一个事务具备很多状态，则会造成状态类太多。
* 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。
* 状态模式对开闭原则支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改哪些负责状态转化的源代码，否则无法切换新增的状态，而且修改某个状态类的行为也需要修改类对应的源代码



Spring-statemechine包，推荐引入，自定义了状态机的逻辑，参考具体文艺汤代码