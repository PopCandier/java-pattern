#### 简单工厂模式

只是将复杂的创建对象逻辑，放在一个工厂类中，使用的时候`new`出工厂对象时，然后再创建出对象。对于使用者来说，只需要调用简单的方法，就可以创建出复杂的对象，且不用考虑具体细节。但是缺点也很明显，就是简单工厂的能力太过强大，什么对象都可以创建出来，不好维护，不符合单一指责和开闭原则。

#### 工厂方法模式

对简单工厂的升级，是对工厂对象的抽象，由于简单工厂的职责太过冗余，所以我们需要抽出一个工厂的接口来划分每个工厂的具体职责，所以工厂方法模式不是对产物的抽象，而是对工厂的抽象，不同的工厂将会拥有自己独特的创建对象逻辑。

巧克力工厂将会生产出不同口味的巧克力，蛋糕工厂将会生产处不同种类的蛋糕。而不是简单工厂，一个甜品工厂可以生产处所有的甜品，虽然这看起来很实用，但是代码耦合性太强，每次修改都需要去修改甜品工厂类，而不是像是工厂方法模式一样，如果你想要新增威化饼干的功能，只需要实现工厂的接口，直接拓展出威化饼干工厂的实现类，并且实现造出威化饼干的逻辑集合，不会对巧克力和蛋糕工厂产生任何影响。而简单工厂，就需要对单独一个方法里的逻辑进行改造了，这样会可能会破坏原有的工厂整体逻辑，也不符合设计原则。

#### 抽象工厂

抽象工厂是对工厂方法的进一次升级，之所以要用这种模式，是因为去聚合一系列产品生产逻辑，形成产品族。

和工厂方法没什么什么区别，唯一的区别就是在中间增加的一层抽象类，抽象类中将巧克力的运输逻辑，销售逻辑，制作逻辑都放在了这个抽象工厂里面，强行让他们聚合在一起，然后将巧克力的运输逻辑实现和销售逻辑实现都放在这里，这样就形成了巧克力的生产链路，一个完整的产品流水，从原材料到出售，这被称为产品族。

然后不同的价格巧克力又形成了所谓的产品等级，这些不同品质的巧克力又会由不同的原材料逻辑和销售手段的工厂去实现。实现完全的职责隔离。

但是坏处也很明显，就是需要维护的类会多，系统理解起来复杂。